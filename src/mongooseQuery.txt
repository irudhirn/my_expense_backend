// what is best or optimized way to apply filter, sorting, limit & pagination in mongoose query?

// Modular Query Binding

const getPaginatedResults = async (Model, queryParams) => {
  const {
    filter = {},              // Filtering conditions (e.g., { status: "active" })
    sortBy = 'createdAt',     // Field to sort by
    sortOrder = 'desc',       // 'asc' or 'desc'
    page = 1,                 // Current page number
    limit = 10,               // Number of items per page
    select = null             // Optional fields to select
  } = queryParams;

  const skip = (page - 1) * limit;

  const sort = { [sortBy]: sortOrder === 'asc' ? 1 : -1 };

  const [results, total] = await Promise.all([
    Model.find(filter)
      .sort(sort)
      .skip(skip)
      .limit(limit)
      .select(select),
    Model.countDocuments(filter)
  ]);

  const totalPages = Math.ceil(total / limit);

  return {
    data: results,
    meta: {
      total,
      totalPages,
      currentPage: page,
      pageSize: limit
    }
  };
};

// How to use

const queryParams = {
  filter: { category: 'tech' },
  sortBy: 'price',
  sortOrder: 'asc',
  page: 2,
  limit: 5,
  select: 'name price'
};

const results = await getPaginatedResults(ProductModel, queryParams);
console.log(results);

// |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// what if in filter object, user sends fields like "page", "sort" & "limit"?
// what if in sortBy, user sends value field name that doesn't exists in document?
// we are setting limit to 10, what if user doesn't want to limit number of results?

1. Filter Object Contains Reserved Fields like page, limit, sortBy
‚úÖ Problem:

If the user sends query params like:

{
  "status": "active",
  "page": 2,
  "limit": 10,
  "sortBy": "price"
}


Then the raw filter object will mistakenly include page, limit, and sortBy ‚Äî which aren‚Äôt actual fields in the document.

‚úÖ Solution:

Use whitelisting or blacklisting to extract pagination/sorting-related keys from the query and treat the rest as filters.

const extractQueryParams = (query) => {
  const {
    page = 1,
    limit = 10,
    sortBy = 'createdAt',
    sortOrder = 'desc',
    select,
    ...filters
  } = query;

  return {
    page: parseInt(page),
    limit: limit === '0' ? 0 : parseInt(limit),
    sortBy,
    sortOrder,
    select,
    filter: filters
  };
};

üß© 2. sortBy is Invalid or Field Doesn't Exist in Schema
‚úÖ Problem:

If the user sends sortBy: 'nonexistentField', Mongoose will still attempt to sort ‚Äî but it will do nothing (no crash, but pointless sort).

This can lead to:

Confusion for the client

Performance overhead on large datasets

‚úÖ Solutions:

Define allowed sortable fields (e.g., whitelist):

const ALLOWED_SORT_FIELDS = ['name', 'createdAt', 'price'];

const sortBy = ALLOWED_SORT_FIELDS.includes(query.sortBy)
  ? query.sortBy
  : 'createdAt';


Optionally validate using Mongoose schema dynamically:

const schemaPaths = Object.keys(Model.schema.paths);
const isValidSort = schemaPaths.includes(query.sortBy);

üß© 3. User Wants All Results (No limit)
‚úÖ Problem:

If user passes limit=0 or omits it, you might not know if they want "all results".

But large datasets can kill performance if you don‚Äôt cap or control result sizes.

‚úÖ Solutions:

Allow limit=0 to mean "no limit", but set a max cap:

const limit = query.limit === '0'
  ? 0 // No limit
  : Math.min(parseInt(query.limit) || 10, 100); // Cap at 100


When limit = 0, you can skip .limit() entirely:

let query = Model.find(filter).sort(sort).skip(skip);
if (limit > 0) query = query.limit(limit);


You may also include a setting like allowUnlimited = true and only allow unlimited results for admin users or trusted systems.

üîß Updated Final Function (Best Practice)
const getPaginatedResults = async (Model, rawQuery = {}) => {
  const {
    page = 1,
    limit = 10,
    sortBy = 'createdAt',
    sortOrder = 'desc',
    select,
    ...filters
  } = rawQuery;

  // Whitelist sortable fields
  const ALLOWED_SORT_FIELDS = ['name', 'createdAt', 'price'];
  const safeSortBy = ALLOWED_SORT_FIELDS.includes(sortBy) ? sortBy : 'createdAt';
  const sort = { [safeSortBy]: sortOrder === 'asc' ? 1 : -1 };

  const safePage = Math.max(1, parseInt(page));
  const safeLimit = limit === '0' ? 0 : Math.min(parseInt(limit) || 10, 100);
  const skip = (safePage - 1) * safeLimit;

  let query = Model.find(filters).sort(sort).skip(skip);
  if (safeLimit > 0) query = query.limit(safeLimit);
  if (select) query = query.select(select);

  const [results, total] = await Promise.all([
    query.exec(),
    Model.countDocuments(filters)
  ]);

  const totalPages = safeLimit > 0 ? Math.ceil(total / safeLimit) : 1;

  return {
    data: results,
    meta: {
      total,
      totalPages,
      currentPage: safePage,
      pageSize: safeLimit
    }
  };
};

‚úÖ Final Tips
Scenario	Solution
User sends page, limit, sortBy in filters	Extract them first
Invalid sort field	Whitelist allowed sort fields
No limit wanted	Support limit=0 but protect backend
Limit too high	Enforce max cap (e.g. limit <= 100)
User requests fields to select	Support optional select param
Big datasets	Index fields used in filter and sort

// |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// how should be the request sent from frontend?

Recommended Frontend Request Format

Assuming you're calling an API like this:

GET /api/products


You can append query parameters like this:

GET /api/products?
  page=2&
  limit=20&
  sortBy=price&
  sortOrder=asc&
  category=electronics&
  brand=apple&
  select=name,price,category


‚úÖ This is a RESTful, readable, and standard way to send filters, pagination, and sorting from the frontend.

üîç Query Parameter Breakdown
Parameter	Purpose	Example
page	Page number for pagination	2
limit	Number of items per page	20
sortBy	Field to sort by	price
sortOrder	Direction of sorting	asc or desc
select	Comma-separated fields to return	name,price,brand
filter fields	Any extra key-value for filtering	brand=apple
üß† Example from Frontend (JavaScript)
üì¶ Using Axios
import axios from 'axios';

const getProducts = async ({
  page = 1,
  limit = 10,
  sortBy = 'createdAt',
  sortOrder = 'desc',
  filters = {},
  select = ''
}) => {
  const params = {
    page,
    limit,
    sortBy,
    sortOrder,
    select,
    ...filters // e.g., { category: 'tech', brand: 'apple' }
  };

  const response = await axios.get('/api/products', { params });
  return response.data;
};

‚úÖ Usage Example
const data = await getProducts({
  page: 2,
  limit: 15,
  sortBy: 'price',
  sortOrder: 'asc',
  select: 'name,price',
  filters: {
    category: 'electronics',
    brand: 'sony'
  }
});

‚ö†Ô∏è Common Frontend Pitfalls to Avoid
Pitfall	Solution
Passing filters in body of GET request	Always use query params for GET
Forgetting to encode values like spaces	Use encodeURIComponent() or let Axios handle it
Using snake_case instead of camelCase	Keep consistent with backend expectations
Sending unused or undefined query params	Strip them before sending
üõ°Ô∏è Optional: Schema for Frontend Query Builder

If you‚Äôre building an advanced frontend (like an admin panel or product search), you can abstract the filter builder:

const query = {
  page: 1,
  limit: 10,
  sortBy: 'rating',
  sortOrder: 'desc',
  filters: {
    price: { $gte: 1000 },
    category: 'laptop'
  },
  select: 'name,price,rating'
};


Then serialize it with a utility like qs:

import qs from 'qs';

const queryString = qs.stringify(query, { encode: true });
axios.get(`/api/products?${queryString}`);

‚úÖ Summary
üß≠ Frontend Sends:

Query parameters like ?page=1&limit=10&sortBy=price&category=phone

Filters as key-value pairs in query string

Optional select for specific fields

üß† Backend Receives:

A well-structured object with clear filter, sort, and pagination keys

Easy to parse and process in a reusable utility function